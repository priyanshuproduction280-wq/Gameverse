/**
 * @file firestore.rules
 * @description Security rules for the GamerVerse application.
 *
 * @section Core Philosophy
 * This ruleset enforces a strict user-ownership model combined with a global admin role.
 * User-specific data is private to the user, while global data like game listings
 * is publicly readable but managed exclusively by administrators.
 *
 * @section Data Structure
 * - /users/{userId}: Contains user profile documents, with an `isAdmin` flag for authorization.
 * - /users/{userId}/carts: Subcollection for a user's shopping cart.
 * - /users/{userId}/orders: Subcollection for a user's past orders.
 * - /games/{gameId}: Publicly readable collection of games.
 * - /payment_qr/current: A single document storing the current payment QR code.
 *
 * @section Key Security Decisions
 * - User data is strictly segregated under /users/{userId} and accessible only by the owning user.
 * - Admin privileges are granted based on an `isAdmin` boolean field on the user's document.
 * - The `isAdmin` field is immutable for clients, meaning users cannot grant themselves admin rights.
 *   This must be done server-side or through the Firebase Console.
 * - Client-side user enumeration is disallowed by restricting `list` access on the top-level `/users` collection.
 *
 * @section Denormalization for Authorization
 * The `isAdmin` flag is a classic denormalization pattern. Instead of a separate roles collection,
 * we place the flag directly on the user object. This requires only one document read (`get()`)
 * to check for admin status anywhere in the rules, which is highly performant.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for concise and reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Checks for ownership on an existing document. Used for update/delete.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // Checks the `isAdmin` flag on the user's own profile document.
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }

    // Ensures the document's internal UID matches the path ID on creation.
    function documentIdMatchesPath(userId) {
      return request.resource.data.uid == userId;
    }
    
    // Ensures a specific field cannot be changed during an update.
    function isImmutable(field) {
      return request.resource.data[field] == resource.data[field];
    }

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own profile, ensuring they are not an admin.
     * @deny (list) Any user attempting to list all user profiles.
     * @principle A user can manage their own profile, but cannot elevate their privileges.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && documentIdMatchesPath(userId) && (!('isAdmin' in request.resource.data) || request.resource.data.isAdmin == false);
      allow update: if isExistingOwner(userId) && isImmutable('uid') && isImmutable('isAdmin');
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages items in a user's shopping cart.
     * @path /users/{userId}/carts/{cartId}
     * @allow (create, list) An authenticated user managing items in their own cart.
     * @deny (get) An authenticated user trying to access another user's cart.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/carts/{cartId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update, delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages a user's order history.
     * @path /users/{userId}/orders/{orderId}
     * @allow (get) The owning user or an admin reading an order.
     * @deny (update) An admin attempting to modify a user's order.
     * @principle User can manage their own data; admins have read-only audit access.
     */
    match /users/{userId}/orders/{orderId} {
      allow get, list: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages publicly available game information.
     * @path /games/{gameId}
     * @allow (list) Any user, signed in or not, listing all games.
     * @deny (create) A non-admin user trying to add a new game.
     * @principle Data is public-read, but write access is restricted to administrators.
     */
    match /games/{gameId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && resource != null;
    }

    /**
     * @description Stores the current payment QR code.
     * @path /payment_qr/current
     * @allow (get) Any user, signed in or not, viewing the QR code.
     * @deny (update) A non-admin user trying to change the QR code.
     * @principle A single, global configuration document that is public-read and admin-write.
     */
    match /payment_qr/current {
      allow get: if true;
      allow list: if false; // Not a collection, but deny explicitly for safety.
      allow create, update: if isAdmin();
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Stores messages from the contact form.
     * @path /contact_messages/{messageId}
     * @allow (create) Any user can submit a message.
     * @deny (update, delete) Messages are immutable from the client.
     * @principle Public write for submissions, but read/list restricted to admins for privacy.
     */
    match /contact_messages/{messageId} {
      allow get, list: if isAdmin();
      allow create: if true;
      allow update, delete: if false;
    }
  }
}
